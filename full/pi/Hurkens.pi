-- from Jonathan Chan
module Hurkens where

data Void : Type where {}
neg : Type -> Type 
neg = \X. X -> Void
P : Type -> Type
P = \S. S -> Type
U : Type @ 1
U = (x : Type @ 0) -> ((P (P x)) -> x) -> P (P x)
tau : (P (P U)) -> U @ 1
tau = \t. \x. \f. \p. t (\s. p (f (s x f)))
sigma : U^1 -> P (P U) @ 2
sigma = \s. s U (\t. tau t)
Delta : P U^1 @ 2
Delta = \y. neg ((p : P U @ 1) -> sigma y p -> p (tau (sigma y)))
Omega : U @ 3
-- Omega doesn't typecheck: expected U but found U^1 in application "p x"
Omega = tau (\p. (x : U^1 @ 2) -> sigma x p -> p x)
M : (x : U^2 @ 3) -> sigma x Delta -> Delta^1 x @ 4
M = \x. \two. \three. three Delta two (\p. three (\y. p (tau (sigma y))))

{-  -- can't type check
R : (p : P U) -> ((x : U) -> sigma x p -> p x) -> p Omega
R = \zero. \one. one Omega (\x. one (tau (sigma x)))
L : neg ((p : P U) -> ((x : U) -> sigma x p -> p x) -> p Omega)
L = \zero. zero Delta M (\p. zero (\y. p (tau (sigma y))))
false : Void
false = L R
-}