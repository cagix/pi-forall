module HurkensEx where
-- Hurkens paradox with explicit level annotations

data Void : Type where {}

neg : Type -> Type @ 0
neg = \X. X -> Void

P : Type -> Type @ 0
P = \S. S -> Type

U : Type @ 1
U = (x : Type @ 0) -> ((P (P x)) -> x) -> P (P x)

tau : (P (P U)) -> U @ 1
tau = \t. \x. \f. \p. t (\s. p (f (s x f)))

sigma : U^1 -> P (P U) @ 2
sigma = \s. s U (\t. tau t)

Delta : P U^1 @ 2
Delta = \y. neg ((p : P U @ 1) -> sigma y p -> p (tau (sigma y)))

-- warning: parser is not good enough for U^1 @ 2, need to have parens around displaced term

Omega : U @ 3
Omega = tau (\p. (x : (U^1) @ 2) -> sigma x p -> p (\y. x y))

M : (x : (U^2) @ 3) -> sigma^1 x Delta -> Delta^1 x @ 4
M = \x. \two. \three. three Delta two (\p. three (\y. p (tau (sigma y))))


{-  -- can't type check
R : (p : P U) -> ((x : U) -> sigma x p -> p x) -> p Omega
R = \zero. \one. one Omega (\x. one (tau (sigma x)))
L : neg ((p : P U) -> ((x : U) -> sigma x p -> p x) -> p Omega)
L = \zero. zero Delta M (\p. zero (\y. p (tau (sigma y))))
false : Void
false = L R
-}
